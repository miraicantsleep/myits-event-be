package tests

import (
	"testing"
	"time"

	"github.com/google/uuid"
	"github.com/miraicantsleep/myits-event-be/entity"
	"github.com/stretchr/testify/assert"
	"gorm.io/gorm"
)

// Helper function to create dummy entities required for UserInvitation
func createPrerequisitesForUserInvitation(db *gorm.DB) (entity.User, entity.Event, entity.Invitation, error) {
	user := entity.User{
		Name:     "Test User for QR",
		Email:    "testuserqr-" + uuid.NewString() + "@example.com", // Ensure unique email
		Password: "password",                                      // Will be hashed by BeforeCreate
		Role:     entity.RoleUser,
	}
	if err := db.Create(&user).Error; err != nil {
		return entity.User{}, entity.Event{}, entity.Invitation{}, err
	}

	event := entity.Event{
		Name:        "Test Event for QR",
		Description: "Event description",
		Date:        time.Now().Add(24 * time.Hour),
		Location:    "Test Location",
		Created_By:  user.ID, // Assuming User ID is needed
		Type:        entity.EventTypeOnline,
		Status:      "upcoming",
	}
	if err := db.Create(&event).Error; err != nil {
		return entity.User{}, entity.Event{}, entity.Invitation{}, err
	}

	invitation := entity.Invitation{
		EventID: event.ID,
		// Users field will be populated via association or UserInvitation directly
	}
	if err := db.Create(&invitation).Error; err != nil {
		return entity.User{}, entity.Event{}, entity.Invitation{}, err
	}

	return user, event, invitation, nil
}

func TestUserInvitation_BeforeCreate_PopulatesQRCode(t *testing.T) {
	db := SetUpDatabaseConnection() // Uses the existing test DB setup
	assert.NotNil(t, db)

	// 0. Clean up any old data to prevent unique constraint violations from previous failed runs
	// This is a bit broad; ideally, we'd clean up specific test data.
	// For robust testing, consider using transactions and rolling back, or more targeted cleanup.
	db.Exec("DELETE FROM user_invitation")
	db.Exec("DELETE FROM invitations")
	db.Exec("DELETE FROM events WHERE name = 'Test Event for QR'") // Be more specific
	db.Exec("DELETE FROM users WHERE email LIKE 'testuserqr-%@example.com'")


	// 1. Create prerequisite entities
	user, event, invitation, err := createPrerequisitesForUserInvitation(db)
	assert.NoError(t, err)

	// 2. Create UserInvitation record
	// GORM creates UserInvitation records when associating via the many2many relationship.
	// We can simulate this by creating the UserInvitation record directly,
	// or by appending to the Users slice of the Invitation and saving.
	// Direct creation is simpler for this specific test.
	userInvitation := entity.UserInvitation{
		UserID:       user.ID,
		InvitationID: invitation.ID,
		RSVPStatus:   entity.RSVPStatusPending,
		// QRCode should be generated by BeforeCreate hook
	}

	// The BeforeCreate hook on UserInvitation should populate QRCode
	err = db.Create(&userInvitation).Error
	assert.NoError(t, err)
	assert.NotEmpty(t, userInvitation.QRCode, "QRCode should be populated by BeforeCreate hook")

	// 3. Verify QRCode is a valid UUID
	_, err = uuid.Parse(userInvitation.QRCode)
	assert.NoError(t, err, "QRCode should be a valid UUID")

	// 4. Clean up (optional, if tests run in transactions or if DB is reset between test suites)
	// For now, manual cleanup is fine as an example.
	// More robust cleanup might involve deleting in reverse order of creation or using ON DELETE CASCADE.
	// Cleaning up specific entities created in this test
	errUIDelete := db.Delete(&userInvitation).Error
	errInvDelete := db.Delete(&invitation).Error
	errEventDelete := db.Delete(&event).Error
	errUserDelete := db.Delete(&user).Error

	assert.NoError(t, errUIDelete, "Error deleting userInvitation")
	assert.NoError(t, errInvDelete, "Error deleting invitation")
	assert.NoError(t, errEventDelete, "Error deleting event")
	assert.NoError(t, errUserDelete, "Error deleting user")
}
