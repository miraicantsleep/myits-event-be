package tests

import (
	"context"
	"fmt"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	// "github.com/miraicantsleep/myits-event-be/constants" // Not strictly needed for this setup, but good for consistency
	"github.com/miraicantsleep/myits-event-be/controller"
	// "github.com/miraicantsleep/myits-event-be/dto" // Not strictly needed for these tests
	"github.com/miraicantsleep/myits-event-be/entity"
	"github.com/miraicantsleep/myits-event-be/repository"
	"github.com/miraicantsleep/myits-event-be/service"
	// "github.com/samber/do" // Not using full DI container for this test setup
	"github.com/stretchr/testify/assert"
	"gorm.io/gorm"
)

// Helper to set up router and invitation controller for integration tests
func SetupInvitationRouterAndController() (*gin.Engine, controller.InvitationController, *gorm.DB) {
	db := SetUpDatabaseConnection() // Assumes SetUpDatabaseConnection is in this package or accessible

	jwtService := service.NewJWTService() // Mock or real, depends if any tested path needs it indirectly
	invitationRepo := repository.NewInvitationRepository(db)
	// The db instance passed to NewInvitationService is for potential direct DB access by service, not just repo
	invitationService := service.NewInvitationService(invitationRepo, jwtService, db)
	invitationController := controller.NewInvitationController(invitationService, jwtService)

	gin.SetMode(gin.TestMode)
	router := gin.Default()
	// Ensure templates are loaded. Path is relative to project root.
	// If tests are run from the project root, "templates/*.html" is correct.
	// If tests are run from within the tests/ directory, "../templates/*.html" is needed.
	// Gin's default behavior for file paths can be tricky; absolute paths or careful relative paths are key.
	// Let's assume tests might be run from project root for `go test ./...` or from `tests/` for `go test`.
	// A more robust way is to determine path relative to current file/package.
	// For now, trying a path that might work if CWD is project root.
	router.LoadHTMLGlob("../templates/*.html") // Adjusted path assuming CWD is tests/
	// If the above doesn't work, try "templates/*.html" assuming CWD is project root.
	// This often depends on how the `go test` command is invoked.
	// For safety, let's try both, or log an error.
	// However, LoadHTMLGlob panics if path is wrong. Let's try one and see test output if it fails.

	// Register only the RSVP routes for this test suite
	// This avoids needing all dependencies for all routes if not being tested.
	apiRoutes := router.Group("/api/invitation") // Mimic actual route structure
	{
		apiRoutes.GET("/rsvp/accept/:token", invitationController.AcceptRSVP)
		apiRoutes.GET("/rsvp/decline/:token", invitationController.DeclineRSVP)
	}

	return router, invitationController, db
}

// Helper function to create a user, event, and a pending invitation for RSVP tests
func createPendingInvitationForRSVPTest(t *testing.T, db *gorm.DB) (entity.User, entity.Event, entity.Invitation, entity.UserInvitation) {
	emailSuffix := uuid.NewString() // For unique emails/names to avoid conflicts

	// It's good practice to defer cleanup within the helper or ensure calling test cleans up.
	// For simplicity, the calling test will handle cleanup of these specific entities.

	user := entity.User{
		Name:     "RSVP Test User " + emailSuffix,
		Email:    "test.rsvpuser." + emailSuffix + "@example.com",
		Password: "password", // Will be hashed by User's BeforeCreate
		Role:     entity.RoleUser,
	}
	assert.NoError(t, db.Create(&user).Error, "Failed to create test user for RSVP")

	event := entity.Event{
		Name:        "RSVP Test Event " + emailSuffix,
		Date:        time.Now().Add(48 * time.Hour),
		Location:    "RSVP Test Location",
		Created_By:  user.ID,
		Type:        entity.EventTypeOnline,
		Status:      "upcoming",
	}
	assert.NoError(t, db.Create(&event).Error, "Failed to create test event for RSVP")

	invitation := entity.Invitation{ // The main invitation record
		EventID: event.ID,
	}
	assert.NoError(t, db.Create(&invitation).Error, "Failed to create invitation record")

	// Create UserInvitation. QRCode will be populated by the DB trigger.
	userInvitation := entity.UserInvitation{
		UserID:       user.ID,
		InvitationID: invitation.ID,
		RSVPStatus:   entity.RSVPStatusPending,
	}
	assert.NoError(t, db.Create(&userInvitation).Error, "Failed to create user_invitation record")

	// Fetch the userInvitation again to get the QRCode generated by the trigger
	var fetchedUserInvitation entity.UserInvitation
	assert.NoError(t, db.Where("user_id = ? AND invitation_id = ?", user.ID, invitation.ID).First(&fetchedUserInvitation).Error)
	assert.NotEmpty(t, fetchedUserInvitation.QRCode, "QR Code should have been generated by DB trigger")

	return user, event, invitation, fetchedUserInvitation // Return the one with QR code
}


func TestRSVP_Accept_Success(t *testing.T) {
	router, _, db := SetupInvitationRouterAndController()
	testUser, testEvent, testInvitation, userInv := createPendingInvitationForRSVPTest(t, db)

	assert.NotEmpty(t, userInv.QRCode, "UserInvitation QRCode token should not be empty")

	req, _ := http.NewRequest(http.MethodGet, "/api/invitation/rsvp/accept/"+userInv.QRCode, nil)
	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code, "HTTP status code should be OK")
	assert.Contains(t, w.Body.String(), "RSVP Confirmed", "Response body should confirm RSVP")
	assert.Contains(t, w.Body.String(), "Accepted", "Response body should indicate Accepted status")

	var updatedUserInv entity.UserInvitation
	err := db.First(&updatedUserInv, "qr_code = ?", userInv.QRCode).Error
	assert.NoError(t, err, "Error fetching updated UserInvitation from DB")
	assert.Equal(t, entity.RSVPStatusAccepted, updatedUserInv.RSVPStatus, "RSVPStatus should be accepted in DB")
	assert.NotNil(t, updatedUserInv.RsvpAt, "RsvpAt should be set in DB")

	// Cleanup
	db.Delete(&updatedUserInv) // or use userInv.ID if it's the same PK as fetched one
	db.Delete(&testInvitation)
	db.Delete(&testEvent)
	db.Delete(&testUser)
}

func TestRSVP_Decline_Success(t *testing.T) {
	router, _, db := SetupInvitationRouterAndController()
	testUser, testEvent, testInvitation, userInv := createPendingInvitationForRSVPTest(t, db)

	assert.NotEmpty(t, userInv.QRCode, "UserInvitation QRCode token should not be empty")

	req, _ := http.NewRequest(http.MethodGet, "/api/invitation/rsvp/decline/"+userInv.QRCode, nil)
	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
	assert.Contains(t, w.Body.String(), "RSVP Updated")
	assert.Contains(t, w.Body.String(), "Declined")

	var updatedUserInv entity.UserInvitation
	db.First(&updatedUserInv, "qr_code = ?", userInv.QRCode)
	assert.Equal(t, entity.RSVPStatusDeclined, updatedUserInv.RSVPStatus)
	assert.NotNil(t, updatedUserInv.RsvpAt)

	// Cleanup
	db.Delete(&updatedUserInv)
	db.Delete(&testInvitation)
	db.Delete(&testEvent)
	db.Delete(&testUser)
}

func TestRSVP_InvalidToken(t *testing.T) {
	router, _, _ := SetupInvitationRouterAndController()
	invalidToken := "this-is-not-a-valid-token"

	req, _ := http.NewRequest(http.MethodGet, "/api/invitation/rsvp/accept/"+invalidToken, nil)
	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
	assert.Contains(t, w.Body.String(), "RSVP Problem")
	assert.Contains(t, w.Body.String(), "sorry, this RSVP link appears to be invalid or has expired")
}

func TestRSVP_AlreadyProcessed(t *testing.T) {
	router, _, db := SetupInvitationRouterAndController()
	testUser, testEvent, testInvitation, userInv := createPendingInvitationForRSVPTest(t, db)

	// First, accept it
	reqAccept, _ := http.NewRequest(http.MethodGet, "/api/invitation/rsvp/accept/"+userInv.QRCode, nil)
	wAccept := httptest.NewRecorder()
	router.ServeHTTP(wAccept, reqAccept)
	assert.Equal(t, http.StatusOK, wAccept.Code)

	// Then, try to decline it
	reqDecline, _ := http.NewRequest(http.MethodGet, "/api/invitation/rsvp/decline/"+userInv.QRCode, nil)
	wDecline := httptest.NewRecorder()
	router.ServeHTTP(wDecline, reqDecline)

	assert.Equal(t, http.StatusOK, wDecline.Code)
	assert.Contains(t, wDecline.Body.String(), "RSVP Problem")
	assert.Contains(t, wDecline.Body.String(), "your RSVP has already been recorded as: accepted")

	// Cleanup
	// db.Delete(&userInv) // userInv here refers to the original fetched one, not an updated one from first accept.
	// It might be better to fetch before delete if PK is not QRCode itself.
	// Or simply delete based on userInv.UserID and userInv.InvitationID
	db.Where("user_id = ? AND invitation_id = ?", userInv.UserID, userInv.InvitationID).Delete(&entity.UserInvitation{})
	db.Delete(&testInvitation)
	db.Delete(&testEvent)
	db.Delete(&testUser)
}
